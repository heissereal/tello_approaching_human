#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import math
# import keyboard
from jsk_recognition_msgs.msg import RectArray
from geometry_msgs.msg import Vector3
from std_msgs.msg import Empty
from geometry_msgs.msg import Twist
import tty, sys, termios, select


class Move_to_human():
    def __init__(self):
        rospy.loginfo('activate')
        self.camera_height = 720
        self.camera_width =  960
        self.fly_flag = False
        self.cmd_vel_pub = rospy.Publisher('/tello/cmd_vel', Twist, queue_size = 10)
        self.cmd_msg = Twist()
        self.takeoff_pub = rospy.Publisher('/tello/takeoff', Empty, queue_size = 10)
        self.land_pub = rospy.Publisher('/tello/land', Empty, queue_size = 10)
        self.rect_sub = rospy.Subscriber('/human/output/rects', RectArray, self.rect_cb)
        self.rects = RectArray()
        self.max_index = 0
        self.max_rect_area = 0.0
        self.max_rect = RectArray()
        self.rect_pos = Vector3()
        self.max_param_area = 500000 #rospy.getparam("~max_param_area", 1.0)
        self.timer = rospy.Timer(rospy.Duration(0.1), self.timerCallback)
        self.rotate_flag = True
        self.n = 0 
        
    def rect_cb(self,msg):
        self.rects = msg
        self.n = len (self.rects.rects)

    def max_rect_cal(self):
        if self.n >= 1:
            max_area = 0
            for i in range(self.n):
                rect = self.rects.rects[i]
                tmp_area = rect.height*rect.width
                if tmp_area >= max_area:
                    max_area = tmp_area
                    self.max_index = i
            self.max_rect = self.rects.rects[self.max_index]
            self.max_rect_area = max_area
        else:
            self.max_rect_area = 0

    # def fly(self):
    #     if keyboard.is_pressed("t"):
    #         self.takeoff_pub.publish()
    #         self.fly_flag = True
    #     if keyboard.is_pressed("space"):
    #         self.land_pub.publish()
    #         self.fly_flag = False

    def rotate_degree_cal(self):
        if self.rotate_flag:
            self.rect_pos.x = (self.max_rect.x + (self.max_rect.width/2)) -(self.camera_width/2)
            self.rect_pos.y = -(self.max_rect.y + (self.max_rect.height/2)) + (self.camera_height/2)
            self.yaw = -self.rect_pos.x * (math.pi/self.camera_width)
            self.cmd_msg.angular.z = self.yaw
            self.cmd_vel_pub.publish(self.cmd_msg)
            time.sleep(1)
            self.cmd_msg.angular.z = 0.0
            self.cmd_vel_pub.publish(self.cmd_msg)
            rospy.loginfo(self.rect_pos.x)
            rospy.loginfo(self.rect_pos.y)
            self.rotate_flag = False

    def getKey(self):
        tty.setraw(sys.stdin.fileno())
        select.select([sys.stdin], [], [], 0)
        key = sys.stdin.read(1)
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
        if key is "t":
            rospy.loginfo("takeoff!")
            self.takeoff_pub.publish()
            self.fly_flag = True
        if key is "l":
            rospy.loginfo("landing!")
            self.land_pub.publish()
            self.fly_flag = False

    def timerCallback(self,event):
        self.getKey()
        if self.fly_flag:
            self.max_rect_cal()
            self.rotate_degree_cal()
            if not rotate_flag:
                if self.max_param_area <= self.max_rect_area:
                    self.cmd_msg.linear.x = 0.0
                    rospy.loginfo(self.max_rect_area)
                else:
                    self.cmd_msg.linear.x = 0.5
                    rospy.loginfo(self.max_rect_area)
                self.cmd_vel_pub.publish(self.cmd_msg)


if __name__ == '__main__':
    rospy.init_node("Move_to_human")
    node = Move_to_human()
    rospy.spin()
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
